<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.5/leaflet.css" />
    <script src="//cdnjs.cloudflare.com/ajax/libs/d3/3.5.6/d3.min.js" type="text/javascript"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.5/leaflet.js"></script>
    <script src='//api.tiles.mapbox.com/mapbox.js/v1.6.4/mapbox.js'></script>
    <link href='//api.tiles.mapbox.com/mapbox.js/v1.6.4/mapbox.css' rel='stylesheet' />
    <link rel="stylesheet" href="/static/assets/style.css" />
    <script src="//ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script>
    <script src="/static/assets/d3.tip.v0.6.3.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/queue-async/1.0.7/queue.min.js"></script>
    <script src="/static/assets/rainbowvis.js"></script>
    <script src="/static/twitter.js"></script>
    <script src='//api.tiles.mapbox.com/mapbox.js/v1.6.4/mapbox.js'></script>
    <script src='//api.mapbox.com/mapbox.js/plugins/leaflet-fullscreen/v0.0.4/Leaflet.fullscreen.min.js'></script>
    <link href='//api.mapbox.com/mapbox.js/plugins/leaflet-fullscreen/v0.0.4/leaflet.fullscreen.css' rel='stylesheet' />
    <script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>
    <style>
    html, body {
        padding: 0;
        margin: 0;
        height: 100%;
        width: 1;
    }

    #map {
        top: 0;
        margin-left: auto;
        margin-right: auto;
        width: 100%;
        /*z-index: 110;*/
        height: 100%;
    }
 
    .travelMarker {
        fill: maroon;
        opacity: 0.75;
    }
    .waypoints {
        fill: black;
        opacity: 0.5;
    }
    .lineConnect {
        fill: none;
        stroke: maroon;
        stroke-width: 6px;
        opacity: .5;
    }
    .locnames {
        fill: black;
        font-family: "Baskerville";
        /*text-shadow: 1px 1px 1px #FFF, 3px 3px 5px #000;*/
        font-weight: 400;
        font-size: 13px;
        text-align: center;
    }
    html, body{
      font-family:"Baskerville"; font-weight: lighter;
      font-size:16px;
      color: black;

    }

    #overlay {
        z-index: 90;
        position: absolute;
        height: 400px;
        right: 0;
        top: 0;
        width: 400px;
        /*background-color: white;
        opacity: .8;*/
        margin: 1em;
    }
    #overlay2 {
        z-index: 110;
        position: absolute;
        height: 400px;
        right: 0;
        top: 0;
        max-width: 400px;
        margin: 1em;
    }
    .hi{
        width: 100%;
        height: 100%;
    }
    #title{
        padding: 4px;
        margin-bottom: .5em;
        font-size: 1.75em;
        /*max-width: auto;*/
        height: auto;
        z-index: 110;
        text-align: right;
        background-color: white;
        opacity: .9;
    }    
    #tweettext{
        margin-bottom: .5em;
        /*margin: 1em;*/
        font-size: .8em;
        width: auto;
        height: auto;
        z-index: 110;
        text-align: right;
        background-color: white;
        opacity: .9;

    }
    .actualtext{
        padding: 4px;
        margin-bottom: .5em;
        /*margin: 1em;*/
        font-size: .8em;
        width: auto;
        height: auto;
        z-index: 110;
        text-align: right;
        background-color: white;
        opacity: .9;

    }
    .twitterborder{
        border: 1px black solid;
    }

    </style>

</head>

<body> <div class="hi">
    <div class="textbox"><div id="overlay"></div>
        <div id="overlay2">
        <div id="title">
            The Daily Cal:
            Protest Mapping
        </div><div class="actualtext"><!-- <blockquote class="twitter-tweet" lang="en"><p lang="fr" dir="ltr">dctests</p>&mdash; Jay Mahabal (@JayMahabal) <a href="https://twitter.com/JayMahabal/status/653427954672766976">October 12, 2015</a></blockquote> -->
            This is an attempt at a real-time visualization that tracks a protest that happens in and around the UC Berkeley area. The goal is for community members to see where the protest is taking place.
        </div>  <div class="actualtext">
            This map was built using Leaflet and d3.js, along with some Twitter stuff.
        </div>
        <div id="tweettext">
        <!-- <blockquote class="twitter-tweet" data-cards="hidden" lang="en"><p lang="en" dir="ltr">Sunsets don&#39;t get much better than this one over <a href="https://twitter.com/GrandTetonNPS">@GrandTetonNPS</a>. <a href="https://twitter.com/hashtag/nature?src=hash">#nature</a> <a href="https://twitter.com/hashtag/sunset?src=hash">#sunset</a> <a href="http://t.co/YuKy2rcjyU">pic.twitter.com/YuKy2rcjyU</a></p>&mdash; US Dept of Interior (@Interior) <a href="https://twitter.com/Interior/status/463440424141459456">May 5, 2014</a></blockquote><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script> --></div>
       
      </div></div>
<div id="map"></div>
   </div>
  
    <script type="text/javascript">

    $(function(){
        queue()
        .await(dataDidLoad);
    });

    function dataDidLoad(error, data) {
    // $.getJSON("{% url 'tweets' %}", function(data) {
    //     console.log(data);
    //     inputjson = data;
    // })
        initializemap();
    };

// function initializemap(data){
    // console.log(data);
    // data = JSON.parse(some_file.json);
    // console.log(data);
    function initializemap(){
    var mapboxTiles = L.tileLayer('https://api.mapbox.com/v4/mapbox.streets/{z}/{x}/{y}@2x.png?access_token=pk.eyJ1Ijoiam1haGFiYWwiLCJhIjoiY2lmZWs2c3N5NzFiZHJzbTdmOTJkZTJ6MyJ9.ZNHhg7C2rn_A5rUOaVKfxA', {
    // var mapboxTiles = L.tileLayer('https://{s}.tiles.mapbox.com/v3/examples.map-zr0njcqy/{z}/{x}/{y}@2x.png', {
        attribution: '<a href="http://www.mapbox.com/about/maps/" target="_blank">Terms &amp; Feedback</a>',
        id: 'jmahabal.nki28jpd'
        // accessToken: 'pk.eyJ1Ijoiam1haGFiYWwiLCJhIjoiY2lmZWs2c3N5NzFiZHJzbTdmOTJkZTJ6MyJ9.ZNHhg7C2rn_A5rUOaVKfxA'
        });
    var map = L.map('map',  { zoomControl: true })
        .addLayer(mapboxTiles)
        .setView([37.87511202, -122.25848635], 15);

    //L.control.fullscreen().addTo(map);

    // new L.Control.Zoom({ position: 'bottomleft' }).addTo(map);
    // we will be appending the SVG to the Leaflet map pane
    // g (group) element will be inside the svg 
    var svg = d3.select(map.getPanes().overlayPane).append("svg");
    // if you don't include the leaflet-zoom-hide when a 
    // user zooms in or out you will still see the phantom
    // original SVG 
    var g = svg.append("g").attr("class", "leaflet-zoom-hide");
    //read in the GeoJSON. This function is asynchronous so
    // anything that needs the json file should be within
    d3.json("{% url 'tweets' %}", function(error, data){
    // var data = d3.JSON("some_file.json");
        var togeojson = '{"type": "FeatureCollection", "crs": { "type": "name", "properties": { "name": "urn:ogc:def:crs:OGC:1.3:CRS84" } }, "features":[';
        // console.log(data[0].quoted_status.coordinates.coordinates);
        // console.log(data.tweets.length);
        // console.log(data.tweets[1734].lat);
        //createdat
        // var testdate = new Date(data[0].created_at);
        // console.log(testdate);
        // console.log(testdate.getMonth());

        for (var i = data.tweets.length - 1; i >= 0; i--) {
            if (data.tweets[i].lat != null){
                //console.log(data.tweets[i]);
                togeojson = togeojson+'{ "type": "Feature", "properties": { "latitude": '+data.tweets[i].lon+', "longitude": '+data.tweets[i].lat+', "time": '+(data.tweets.length - i)+', "tweetid": '+(data.tweets[i].tweetid)+', "id": "route1", "name":"'+data.tweets[i].text+'" }, "geometry": { "type": "Point", "coordinates": [ '+data.tweets[i].lon+', '+data.tweets[i].lat+' ] } },';
            };
        };
        togeojson = togeojson.slice(0, togeojson.length-1);
        togeojson = togeojson + "]}";
        // console.log(togeojson);
        togeojson = JSON.parse(togeojson);
        console.log(togeojson);
    //d3.json(togeojson, function(collection) {
       // console.log(collection);
        
        //console.log(collection);
        // this is not needed right now, but for future we may need
        // to implement some filtering. This uses the d3 filter function
        // featuresdata is an array of point objects
        var featuresdata = togeojson.features.filter(function(d) {
            //console.log(d);
            return d.properties.id == "route1"
        })

        // change this
        //featuresdata = featuresdata.reverse();

        //stream transform. transforms geometry before passing it to
        // listener. Can be used in conjunction with d3.geo.path
        // to implement the transform. 
        var transform = d3.geo.transform({
            point: projectPoint
        });
        //d3.geo.path translates GeoJSON to SVG path codes.
        //essentially a path generator. In this case it's
        // a path generator referencing our custom "projection"
        // which is the Leaflet method latLngToLayerPoint inside
        // our function called projectPoint
        var d3path = d3.geo.path().projection(transform);
        // Here we're creating a FUNCTION to generate a line
        // from input points. Since input points will be in 
        // Lat/Long they need to be converted to map units
        // with applyLatLngToLayer
        var toLine = d3.svg.line()
            .interpolate("linear")
            .x(function(d) {
                return applyLatLngToLayer(d).x
            })
            .y(function(d) {
                return applyLatLngToLayer(d).y
            });
        // From now on we are essentially appending our features to the
        // group element. We're adding a class with the line name
        // and we're making them invisible
        // these are the points that make up the path
        // they are unnecessary so I've make them
        // transparent for now
        var ptFeatures = g.selectAll("circle")
            .data(featuresdata)
            .enter()
            .append("circle")
            .attr("r", 3)
            .attr("class", "waypoints");
        // Here we will make the points into a single
        // line/path. Note that we surround the featuresdata
        // with [] to tell d3 to treat all the points as a
        // single line. For now these are basically points
        // but below we set the "d" attribute using the 
        // line creator function from above.
        var linePath = g.selectAll(".lineConnect")
            .data([featuresdata])
            .enter()
            .append("path")
            .attr("class", "lineConnect");
        // This will be our traveling circle it will
        // travel along our path
        var marker = g.append("circle")
            .attr("r", 10)
            .attr("id", "marker")
            .attr("class", "travelMarker");
        // For simplicity I hard-coded this! I'm taking
        // the first and the last object (the origin)
        // and destination and adding them separately to
        // better style them. There is probably a better
        // way to do this!
        ///
        var listoftweets = featuresdata
        // console.log(listoftweets)
        // console.log(featuresdata);

        // var mapTip = d3.tip()
        // .attr('class', 'map-tip')
        // // .style('class', 'blockquote')
        // .attr("class", "blockquote")
        // .offset([-4, 0]);

        // g.call(mapTip);

        //console.log(listoftweets);

        var waypointHover = g.selectAll(".tweetLocations")
            .data(listoftweets)
            .enter()
            .append("circle", ".tweetLocations")
            .attr("r", 3)
            .style("opacity", ".5");
            // .on("mouseover", function(d, i){
            //     updateTweet('<blockquote class="twitter-tweet" lang="en"><p lang="en" dir="ltr">Sunsets don&#39;t get much better than this one over <a href="https://twitter.com/GrandTetonNPS">@GrandTetonNPS</a>. <a href="https://twitter.com/hashtag/nature?src=hash">#nature</a> <a href="https://twitter.com/hashtag/sunset?src=hash">#sunset</a> <a href="http://t.co/YuKy2rcjyU">pic.twitter.com/YuKy2rcjyU</a></p>&mdash; US Dept of Interior (@Interior) <a href="https://twitter.com/Interior/status/463440424141459456">May 5, 2014</a></blockquote><script async src="//platform.twitter.com/widgets.js" charset="utf-8">');
            //     //alert("sad");
            //     // d3.select(this).attr("r", 20)
            //     //var tipText = d.properties.name;
            //     // need: text, name, handle, 
            //     // var tipText = "https://api.twitter.com/1/statuses/oembed.json?url=https://twitter.com/Interior/status/463440424141459456";
            //     // var tipText = (function(d) { return '<blockquote class="twitter-tweet" lang="en"><p lang="en" dir="ltr">Sunsets don&#39;t get much better than this one over <a href="https://twitter.com/GrandTetonNPS">@GrandTetonNPS</a>. <a href="https://twitter.com/hashtag/nature?src=hash">#nature</a> <a href="https://twitter.com/hashtag/sunset?src=hash">#sunset</a> <a href="http://t.co/YuKy2rcjyU">pic.twitter.com/YuKy2rcjyU</a></p>&mdash; US Dept of Interior (@Interior) <a href="https://twitter.com/Interior/status/463440424141459456">May 5, 2014</a></blockquote><script async src="//platform.twitter.com/widgets.js" charset="utf-8">'; });

            //     // mapTip.html(tipText);
            //     // mapTip.show();
            //     })
            // .on("mouseout",function(){
            //     $("tweettext").empty();
            //     // d3.select(this).attr("r", 3)
            //     // mapTip.hide();
            // });

        function updateTweet(tweetinfo) {
            console.log("updateTweet");
            console.log(tweetinfo);
            var textint = tweetinfo;
            twttr.widgets.createTweet(
                textint.toString(),
              // tweetinfo.toString(),
              document.getElementById('tweettext')
            );
            // console.log(tweetinfo);
            // var sidebartweet = d3.select("#tweettext")
            //     .text((tweetinfo))
            //     .attr("class", "blockquote")
            //     .attr("class", "twitter-tweet");
            // console.log("hi");
        }

        ///
        var mostRecent = [featuresdata[featuresdata.length - 1]]
        // console.log(originANDdestination)
        var begend = g.selectAll(".drinks")
            .data(mostRecent)
            .enter()
            .append("circle", ".drinks")
            .attr("r", 3)
            .style("fill", "black")
            .style("opacity", "1");
        // I want names for my coffee and beer
        var text = g.selectAll("text")
            .data(mostRecent)
            .enter()
            .append("text")
            .text(function(d) {
                console.log(d);
                updateTweet(d.properties.tweetid);
                // return d.properties.name
            })
            .attr("class", "locnames")
            .attr("x", function(d) {
                return -50;
            })
            .attr("y", function(d) {
                return -15;
            });
        // when the user zooms in or out you need to reset
        // the view
        map.on("viewreset", reset);
        // this puts stuff on the map! 
        reset();
        transition();
        // Reposition the SVG to cover the features.
        function reset() {
            var bounds = d3path.bounds(togeojson),
                topLeft = bounds[0],
                bottomRight = bounds[1];

            //console.log("hi"+bounds);
            // here you're setting some styles, width, heigh etc
            // to the SVG. Note that we're adding a little height and
            // width because otherwise the bounding box would perfectly
            // cover our features BUT... since you might be using a big
            // circle to represent a 1 dimensional point, the circle
            // might get cut off.
            text.attr("transform",
                function(d) {
                    return "translate(" +
                        applyLatLngToLayer(d).x + "," +
                        applyLatLngToLayer(d).y + ")";
                });
            // for the points we need to convert from latlong
            // to map units
            begend.attr("transform",
                function(d) {
                    return "translate(" +
                        applyLatLngToLayer(d).x + "," +
                        applyLatLngToLayer(d).y + ")";
                });
            waypointHover.attr("transform",
                function(d) {
                    return "translate(" +
                        applyLatLngToLayer(d).x + "," +
                        applyLatLngToLayer(d).y + ")";
                });
            ptFeatures.attr("transform",
                function(d) {
                    return "translate(" +
                        applyLatLngToLayer(d).x + "," +
                        applyLatLngToLayer(d).y + ")";
                });
            // again, not best practice, but I'm harding coding
            // the starting point
            marker.attr("transform",
                function() {
                    var y = featuresdata[0].geometry.coordinates[1]
                    var x = featuresdata[0].geometry.coordinates[0]
                    return "translate(" +
                        map.latLngToLayerPoint(new L.LatLng(y, x)).x + "," +
                        map.latLngToLayerPoint(new L.LatLng(y, x)).y + ")";
                });
            // Setting the size and location of the overall SVG container
            // console.log("testsvgheight");
            // console.log(bottomRight);
            // console.log(featuresdata);

            svg.attr("width", bottomRight[0] - topLeft[0] + 120)
                .attr("height", bottomRight[1] - topLeft[1] + 120)
                .style("left", topLeft[0] - 50 + "px")
                .style("top", topLeft[1] - 50 + "px");
            // linePath.attr("d", d3path);
            linePath.attr("d", toLine)
            // ptPath.attr("d", d3path);
            g.attr("transform", "translate(" + (-topLeft[0] + 50) + "," + (-topLeft[1] + 50) + ")");
        } // end reset
        // the transition function could have been done above using
        // chaining but it's cleaner to have a separate function.
        // the transition. Dash array expects "500, 30" where 
        // 500 is the length of the "dash" 30 is the length of the
        // gap. So if you had a line that is 500 long and you used
        // "500, 0" you would have a solid line. If you had "500,500"
        // you would have a 500px line followed by a 500px gap. This
        // can be manipulated by starting with a complete gap "0,500"
        // then a small line "1,500" then bigger line "2,500" and so 
        // on. The values themselves ("0,500", "1,500" etc) are being
        // fed to the attrTween operator
        function transition() {
            linePath.transition()
                .duration(7500)
                .attrTween("stroke-dasharray", tweenDash)
                .each("end", function() {
                    d3.select(this).call(transition);// infinite loop
                }); 
        } //end transition
        // this function feeds the attrTween operator above with the 
        // stroke and dash lengths
        function tweenDash() {
            return function(t) {
                //total length of path (single value)
                var l = linePath.node().getTotalLength(); 
            
                // this is creating a function called interpolate which takes
                // as input a single value 0-1. The function will interpolate
                // between the numbers embedded in a string. An example might
                // be interpolatString("0,500", "500,500") in which case
                // the first number would interpolate through 0-500 and the
                // second number through 500-500 (always 500). So, then
                // if you used interpolate(0.5) you would get "250, 500"
                // when input into the attrTween above this means give me
                // a line of length 250 followed by a gap of 500. Since the
                // total line length, though is only 500 to begin with this
                // essentially says give me a line of 250px followed by a gap
                // of 250px.
                interpolate = d3.interpolateString("0," + l, l + "," + l);
                //t is fraction of time 0-1 since transition began
                var marker = d3.select("#marker");
                
                // p is the point on the line (coordinates) at a given length
                // along the line. In this case if l=50 and we're midway through
                // the time then this would 25.
                var p = linePath.node().getPointAtLength(t * l);
                //Move the marker to that point
                marker.attr("transform", "translate(" + p.x + "," + p.y + ")"); //move marker
                // console.log(interpolate(t))
                return interpolate(t);
            }
        } //end tweenDash
        // Use Leaflet to implement a D3 geometric transformation.
        // the latLngToLayerPoint is a Leaflet conversion method:
        //Returns the map layer point that corresponds to the given geographical
        // coordinates (useful for placing overlays on the map).
        function projectPoint(x, y) {
            var point = map.latLngToLayerPoint(new L.LatLng(y, x));
           // console.log(point);
            this.stream.point(point.x, point.y);
        } //end projectPoint
    });
    // similar to projectPoint this function converts lat/long to
    // svg coordinates except that it accepts a point from our 
    // GeoJSON
    function applyLatLngToLayer(d) {
        // console.log(d);
        var y = d.geometry.coordinates[1]
        var x = d.geometry.coordinates[0]
        // console.log(y, x);
        return map.latLngToLayerPoint(new L.LatLng(y, x))
    
    }
}

//}
    </script>
</body>

</html>